// TEAM: forwarding_platform

syntax = "proto3";

package flexport.executioncoordinator.executiontask.v1;

import "flexport/executioncoordinator/executiontask/v1/params/air_consol_execution_task_params.proto";
import "flexport/executioncoordinator/executiontask/v1/params/air_direct_execution_task_params.proto";
import "flexport/executioncoordinator/executiontask/v1/params/barge_execution_task_params.proto";
import "flexport/executioncoordinator/executiontask/v1/params/carbon_services_task_params.proto";
import "flexport/executioncoordinator/executiontask/v1/params/cargo_consolidation_execution_task_params.proto";
import "flexport/executioncoordinator/executiontask/v1/params/cargo_receipt_execution_task_params.proto";
import "flexport/executioncoordinator/executiontask/v1/params/cargo_release_execution_task_params.proto";
import "flexport/executioncoordinator/executiontask/v1/params/customs_declaration_execution_task_params.proto";
import "flexport/executioncoordinator/executiontask/v1/params/customs_import_execution_task_params.proto";
import "flexport/executioncoordinator/executiontask/v1/params/drayage_execution_task_params.proto";
import "flexport/executioncoordinator/executiontask/v1/params/ocean_consol_execution_task_params.proto";
import "flexport/executioncoordinator/executiontask/v1/params/ocean_fcl_execution_task_params.proto";
import "flexport/executioncoordinator/executiontask/v1/params/rail_direct_execution_task_params.proto";
import "flexport/executioncoordinator/executiontask/v1/params/trucking_consol_execution_task_params.proto";
import "flexport/executioncoordinator/executiontask/v1/params/trucking_direct_execution_task_params.proto";
import "flexport/executioncoordinator/types/routeshape/v1/route_shape.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";

option java_multiple_files = true;
option java_outer_classname = "ExecutionTaskProto";
option java_package = "com.flexport.executioncoordinator.executiontask.v1";
option ruby_package = "Flexport::ExecutionCoordinator::ExecutionTask::V1";

// This file: http://go/et-proto.
//
// A mutable ExecutionTask entity representing a high-level unit of work that Flexport delegates
// to a service provider (either internal or external) to execute our obligations for a shipment.
//
//   Most recently updated:
//   go/et-latest
//
//   By fid:
//   go/fid/flx::execution_coordinator:execution_task:5179b778-de15-4847-949c-3f2ff47763b6
//
// The list of ExecutionTasks associated with an ExecutionOrder is Flexport's plan for execution:
// which service provider is responsible for doing what when. A simple ocean FCL shipment might
// have these tasks:
//
// - task1: drayage from factory to port1
// - task2: ocean_fcl from port1 to port2
// - task3: drayage from port2 to client_warehouse
// - task4: customs_declaration for import into destination_country
//
// Sometimes ExecutionTasks correspond 1:1 with requests sent to external vendors. For example,
// a drayage ExecutionTask will usually result an delivery order being sent to a trucking carrier.
// For ocean FCL, an ExecutionTask yields a carrier booking. For customs, a clearance request.
// Note that an ExecutionTask could be for physical movement or a value-add service.
//
// In other cases, ExecutionTasks may correspond to work performed internally within Flexport. An
// insourced LCL shipment, for example, might have these ExecutionTasks:
//
// - trucking of pallets/cartons from factory to cfs1
// - cargo_receipt of pallets/cartons at cfs1
// - ocean_consol from cfs1 to cfs2
// - cargo_release of pallets/cartons at cfs2
// - trucking of pallets/cartons from cfs2 to client_warehouse
//
// The ocean_consol task for this shipment covers the entire lifecycle of consolidation:
// consolidation and release from origin CFS, drayage to port, main carriage of the consolidated
// container, drayage from destination port, receipt and deconsolidation at destination CFS.
//
// There is a separate ExecutionOrder for managing the parent consolidated load's execution, and
// the ocean_consol ExecutionTask on the child ExecutionOrder is primarily a pointer to this parent.
//
// More details on go/et-wiki.
//
message ExecutionTask {
  //
  // Identifier for the entity.
  string fid = 1;
  //
  // Time the entity was created.
  google.protobuf.Timestamp created_time = 2;
  //
  // Revision number of the entity. Increments by one each time the entity is mutated, starting
  // at 1. Included in events and reads from the ExecutionCoordinator; ignored during writes.
  uint32 revision = 3;
  //
  // Time the current entity revision was created.
  google.protobuf.Timestamp revision_created_time = 4;
  //
  // The ExecutionPlan revision number in which this ExecutionTask revision was created, ie the
  // revision during which this ExecutionTask was most recently updated.
  uint32 revision_created_in_plan_revision = 10;
  //
  // Unique identifier for the ExecutionOrder corresponding to the ExecutionTask.
  string execution_order_fid = 5;
  //
  // Whether the ExecutionTask can be automatically replanned in a later iteration.
  // (This field can be set to false when eg a human planner manually overrides the automated
  // planner. It could also be set to true in a later iteration if something changes on the
  // ExecutionPlanner side.)
  google.protobuf.BoolValue automated_replanning_enabled = 6;
  //
  // The shape of the route for this ExecutionTask.
  // Why is the route_shape part of the ExecutionTask?
  // In practice, the shape of the route may be a combination of planning and execution data
  // in that during execution a carrier may change the route within the scope of their ExecutionTask,
  // while still conforming to the requested origin and destination.
  // However, the ExecutionPlan represents the current plan, including these “replanning” changes during execution,
  // so it should be updated similar to how the ExecutionOrder is updated
  // on an ongoing basis as customer requirements for a shipment evolve.
  flexport.executioncoordinator.types.routeshape.v1.RouteShape route_shape = 12;
  //
  // The status of the ExecutionTask, eg stubbed or ready for execution.
  ExecutionTaskPlanningStatus planning_status = 7;
  //
  // The vertical-specific parameters for the task.
  ExecutionTaskParams params = 9;
}

// A wrapper message for ExecutionTask parameters.
// Next ID: 19
// Also update the following files:
// ExecutionCoordinator's GqlExecutionTaskParamsCase.java
// Test in common/jvm/src/test/java/com/flexport/forwardingutil/parse/ExecutionTaskParserTest.java
// flexport/executioncoordinator/types/enums/v1/execution_task_params_case.proto
message ExecutionTaskParams {
  oneof params {
    AirConsolExecutionTaskParams air_consol = 1;
    AirDirectExecutionTaskParams air_direct = 10;
    BargeExecutionTaskParams barge = 18;
    CustomsDeclarationExecutionTaskParams customs_declaration = 11;
    CustomsImportExecutionTaskParams customs_import = 17;
    DrayageExecutionTaskParams drayage = 3;
    TruckingConsolExecutionTaskParams trucking_consol = 12;
    TruckingDirectExecutionTaskParams trucking_direct = 13;
    OceanFclExecutionTaskParams ocean_fcl = 6;
    OceanConsolExecutionTaskParams ocean_consol = 7;
    CargoReceiptExecutionTaskParams cargo_receipt = 8;
    CargoReleaseExecutionTaskParams cargo_release = 9;
    CargoConsolidationExecutionTaskParams cargo_consolidation = 14;
    RailDirectExecutionTaskParams rail_direct = 15;
    CarbonServicesTaskParams carbon_services = 16;
  }
}

// The planning status of an ExecutionTask. Set by planning systems when updating ExecutionTasks.
// When adding a new value, please update the GraphQL type in execution_coordinator/src/main/resources/schema.graphqls.
enum ExecutionTaskPlanningStatus {
  EXECUTION_TASK_PLANNING_STATUS_INVALID = 0;
  //
  // The ExecutionTask has been stubbed from an ExecutionOrder/ExecutionOffering but not yet
  // fully planned.
  //
  // When an ExecutionOrder is received by the ExecutionCoordinator, an initial ExecutionPlan
  // skeleton is created with basic details from the ExecutionOrder such as origins, destinations,
  // but not eg specific carriers or dates (unless these are prescribed on the ExecutionOrder).
  //
  // The stubs are useful for showing the high-level tentative route in the client app and ops
  // tools, similar to the skeleton graph that's automatically created when a quote is accepted.
  // Stubbed tasks may be fleshed out, cancelled, or replaced during planning.
  //
  // ExecutionProviders should NOT execute against ExecutionTasks with this planning status, ie
  // before they are ready for execution.
  EXECUTION_TASK_PLANNING_STATUS_STUBBED = 1;
  //
  // The task has been fully planned and is ready for execution.
  //
  // When an ExecutionTask's params are fleshed out by a planner, then details like the carrier and
  // expected dates are set as params. If replanning occurs, the task remains in this status, but
  // its params may change.
  //
  // The ExecutionProvider can begin executing against an ExecutionTask once it has this status.
  //
  // Planners should use ExecutionTaskStateEvents emitted by ExecutionProviders to determine
  // whether it is safe to replan. The exact cutoff criteria will differ by mode, so it's up to
  // the planner/provider to agree which events imply that replanning is not possible.
  EXECUTION_TASK_PLANNING_STATUS_READY_FOR_EXECUTION = 2;
  //
  // The task has been cancelled.
  //
  // Once cancelled, ExecutionProviders will attempt to cancel the booking and
  // update ExecutionTaskExecutionStatus.
  //
  // The ExecutionPlanner may explicitly cancel an ExecutionTask by producing
  // an ExecutionTask with this value set. Or the ExecutionPlanner may
  // simply send back an new ExecutionPlan without including a new
  // ExecutionTask for an existing ExecutionTask, and the
  // ExecutionCoordinator is responsible for detecting this cancellation and
  // creating a new ExecutionTask with the status set to cancelled.
  EXECUTION_TASK_PLANNING_STATUS_CANCELLED = 3;
}
