// TEAM: application_framework

syntax = "proto3";

package flexport.actionlog.tokengeneration.v1beta1;

option java_multiple_files = true;
option java_outer_classname = "TokenGenerationApiProto";
option java_package = "com.flexport.actionlog.tokengeneration.v1beta1";
option ruby_package = "Flexport::ActionLog::TokenGeneration::V1Beta1";

import "flexport/actionlog/tokenconfig/v1beta1/token_config.proto";

//
// * Service Boundary Documentation:
// * -------------------------------
// * The Token generation API for the Action Log Network isolated service.
// * The purpose of this GRPC service is for the Action Log NIS to provide scoped ActionLog tokens
// * that power the <ActionLog...> react component (The component for rendering Action Logs on the frontend).
// * The generic <ActionLog...> react component passes this token to the graphql endpoints living in the ActionLog NIS.
// * The NIS uses this token to:
// * - Figure out what actions types to return to this component
// * - What actors should the action be scoped to
// * - What targets should the actions be scoped to
// * - Return actions with a particular set of properties
// * - What filters are to be rendered on the <ActionLog...> react component
// * - (Note examples below don't use proto instantiations for explanation and use pseudocode instead)
// * Each action log token request has five arguments:
// *  - Actions: List of "registered" (see how to register your action in go/actionlog) actions
//             ex: ["ExampleAction", "ShipmentChallengedAccessAction", ]
//      This argument scopes the token to return any (A reader may note this is implemented as an OR clause) of the actions present in that list
//
// *  - Actors: List of targets. An Actor is an entity that is opaque to action. An Entity is an opaque piece of data
//      that contains a "type" and "id". This argument scopes the action to return all actions that have been performed by any of these actors (A reader may note this is an OR clause)
//      ex: pseudocode: actors =  [Entity(entity_id: '123', type: 'User')]. If this argument is nil, no scope is placed.
//      If this argument is an empty array, it returns actions that have no actor which is no actions (Aka 0 actions returned)
//
// *  - Targets: List of actors. An Actor is an entity that is opaque to action. An Entity is an opaque piece of data
//      that contains a "type" and "id".  This argument scopes the action to return all actions that have been performed on any of these targets (A reader may note this is an OR clause))
//      ex: pseudocode: actors =  [Entity(entity_id: '123', type: 'User')]. If this argument is nil, no scope is placed.
//     If this argument is an empty array, this argument scopes the action to return all actions that have been performed on any of these targets, which is no target
//     (Aka 0 actions returned)
//
//     Note: [] value for actors or targets return no actions while nil value returns all. This is for completeness sake.
//     The behavior when actors/targets is an empty array is based on the supposition in our code that every "action" logged to actionLog
//     has an "Actor" and has a "Target". Thus there are no actions in the data storage that don't have an actor/target associated with them.
// *
// *  - Properties: List of property scopes. Every action logged to actionLog has a properties field which is either nil or a json object/ruby hash.
//      This list is to scope actions to only actions having a certain property. If this field is nil, we place no scoping on the actions returned to the frontend by property.
//      If this list is empty, the token is scoped to return actions with no properties (Return actions with nil properties).
//      If the list is non-empty, it returns
//
//      What is a property scope?
//      ans: A property scope is one-level dictionary like
//      {"property1" => 10, "property2" => true, "property3.property4" => "foo"}. It means we should
//      return all actions that contain a property hash having a field property 1 with integer value 10,
//      field property2 with boolean value true, and a nested field property4 within field property3 having
//      string value "foo".
//
// *  - Filters. List of filters. This encodes the list of UI user filters the <ActionLog..> component will render on the frontend.
// *    Currently we support filtering by action type, actor, target and occurred_at (date range filter)
// *
// *
// *  To learn more about what ActionLog is go to go/actionlog and reach out to the #app-framework
//

// Set of GRPC APIS to generate action log tokens to power the <ActionLog..> react component.
service TokenGenerationAPI {
  // Generate a scoped Action Log token. Ultimately, this token is passed to the frontend
  // to power the generic <ActionLog...> react component (which makes graphql queries to the ActionLog NIS with token as an argument containing
  // authorizations and scopes and clamps)

  //
  //   * Scenarios for known failed responses:
  //   *   - Pass in an ActionType that is not registered in the ActionLog service in the action types array.
  //   *   - Pass in an unknown filter type. ActionLog has a set of filter types (Ex: OccuredAt filter, action type filter, actor filter, target filter)
  //         that you can enable on the component on the token. If you specify,
  //         a type that isn't in this set, you will get a failure
  //   *   - Pass in a nil in the actors or targets array ex: [actor1, nil, actor2]
  //   *   - Pass in a nil in the filters array ex: [filter1, nil, filter2]
  //   *   - Pass in a nil in the property scopes array [{<property scope >}, nil, {<property scope 2>}]
  //   *   - Pass in a property value of an unrecognized type aka not :STRING_VALUE, :INTEGER_VALUE or :BOOLEAN_VALUE

  // The GRPC API to generate an action log token.
  rpc GenerateActionLogToken(GenerateActionLogTokenRequest) returns (GenerateActionLogTokenResponse);
}

// The request message for generating the scoped jwt token that defines the filters and the scoped actions to return to the frontend.
message GenerateActionLogTokenRequest {
  repeated string actions = 1;
  flexport.actionlog.tokenconfig.v1beta1.EntitiesTokenConfig actors_config = 2;
  flexport.actionlog.tokenconfig.v1beta1.EntitiesTokenConfig targets_config = 3;
  flexport.actionlog.tokenconfig.v1beta1.PropertiesArrayTokenConfig properties_config = 4;
  repeated flexport.actionlog.tokenconfig.v1beta1.FilterTokenConfig filters_config = 5;
}

// The response message containing the scoped action log token.
message GenerateActionLogTokenResponse {
  string token = 1;
}
