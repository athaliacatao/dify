// TEAM: commerce_charges

syntax = "proto3";

package flexport.catalog.charge.v2beta1;

option java_multiple_files = true;
option java_outer_classname = "ChargeApiProto";
option java_package = "com.flexport.catalog.charge.v2beta1";
option ruby_package = "Flexport::Catalog::Charge::V2Beta1";

import "flexport/catalog/charge/v2beta1/charge.proto";
import "flexport/catalog/chargetype/v2beta1/charge_type.proto";
import "google/protobuf/wrappers.proto";

// The charge service definition.
service ChargeAPI {
  // Evaluates charges.
  // Evaluates the cost and sell rates into amounts as well as any subject-to conditions which may
  // be present. The rates of some charges depend on the costs of other charges so the entire set
  // of charges should be evaluated together. Dormant dependency charges are not typically included
  // in these dependant charges. It's possible that one of these dependency charges has subject-to
  // conditions. So if evaluating that charge would activate it, we'd want to update the amount of
  // any dependant charges. This is a long way of saying rates and subject-to-ness of charges can
  // affect each other and that's why they should be evaluated together.
  rpc EvaluateCharges(EvaluateChargesRequest) returns (EvaluateChargesResponse);
  // Returns a list of charge types and related metadata.
  rpc QueryChargeDefinitions(QueryChargeDefinitionsRequest) returns (QueryChargeDefinitionsResponse);
  // Return charge type details.
  rpc GetChargeDefinition(GetChargeDefinitionRequest) returns (GetChargeDefinitionResponse);
  // Creates a charge definition or provides errors if unable to.
  rpc CreateChargeDefinition(CreateChargeDefinitionRequest) returns (CreateChargeDefinitionResponse);
  // Deletes a charge definition or provides errors if unable to.
  rpc DeleteChargeDefinition(DeleteChargeDefinitionRequest) returns (DeleteChargeDefinitionResponse);
}

message EvaluateChargesRequest {
  repeated EvaluableChargeDto charges = 1;
  // Shared context or state information necessary to evaluate the charges.
  EvaluateChargesContext context = 2;
  map<string, string> exchange_rates = 3 [deprecated = true];
}

message EvaluateChargesResponse {
  repeated EvaluatedChargeDto charges = 1;
  EvaluatedRateDto total_cost = 2;
  EvaluatedRateDto total_sell = 3;
}

message QueryChargeDefinitionsRequest {}

message QueryChargeDefinitionsResponse {
  repeated catalog.chargetype.v2beta1.ChargeTypeDto charge_types = 1;
}

message GetChargeDefinitionRequest {
  google.protobuf.StringValue slug = 1;
}

message GetChargeDefinitionResponse {
  catalog.chargetype.v2beta1.ChargeTypeDto charge_type = 1;
}

message CreateChargeDefinitionRequest {
  google.protobuf.StringValue slug = 1;
  google.protobuf.StringValue title = 2;
  google.protobuf.StringValue created_by_id = 3;
  google.protobuf.StringValue updated_by_id = 4;
}

message CreateChargeDefinitionResponse {
  repeated string errors = 1;
  catalog.chargetype.v2beta1.ChargeTypeDto charge_type = 2;
}

message DeleteChargeDefinitionRequest {
  google.protobuf.StringValue slug = 1;
}

message DeleteChargeDefinitionResponse {
  repeated string errors = 1;
}
