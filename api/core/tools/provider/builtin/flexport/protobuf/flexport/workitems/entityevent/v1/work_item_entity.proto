// TEAM: work_management

syntax = "proto3";

package flexport.workitems.entityevent.v1;

import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";

option java_multiple_files = true;
option java_outer_classname = "WorkItemEntityProto";
option java_package = "com.flexport.workitems.entityevent.v1";
option ruby_package = "Flexport::WorkItems::EntityEvent::V1";

// SOA ingestion representation of a Work Item. Work items are defined in the
// work items service (under work_items/ in the monorepo).
message WorkItemEntity {
  //
  // Section: Work Item Identity
  //
  // Globally unique. Will always start with flx::work_items:work_item
  string fid = 10;
  //
  // Upsert key of a work item. Only unique with a particular work_item_type.
  // This is usually an external/foreign key, but work items only treats it
  // and an opaque string.
  string upsert_key = 11;
  //
  // Possibilities are defined in work_items/src/main/resources/work_item_types/
  string work_item_type = 12;
  //
  // Section: Foreign keys
  //
  // Actors that the work item is assigned to. Not guaranteed to be user FIDs.
  repeated string assignee_fids = 20;
  //
  // Topics that the work item relates to. Can represent any resource.
  repeated string topic_fids = 21;
  //
  // If topic_fids contains exactly one FID of type flx::core:shipment, then
  // it will be included here. If there are more than one shipments in
  // topic_fids, this will be empty.
  google.protobuf.StringValue shipment_fid = 22;
  //
  // Section: User foreign keys
  //
  // TODO: store which user completed the work item
  // The user which completed the work item. Availability of this field varies
  // by work item type, as it is on the caller to supply which user completed a
  // work item.
  google.protobuf.StringValue completed_by_fid = 30;
  //
  // TODO: store which user snoozed the work item
  google.protobuf.StringValue snoozed_by_fid = 31;
  //
  // TODO: store which user unsnoozed the work item
  google.protobuf.StringValue unsnoozed_by_fid = 32;
  //
  // TODO: store which user last updated the work item
  // The user which last updated the work item. Availability of this field
  // varies by work item type, as it is on the caller to supply which user
  // caused a work_item update.
  google.protobuf.StringValue updated_by_fid = 33;
  //
  // Section: Work Item Status
  //
  // Whether the work item is applicable or not. If a work item is not
  // applicable, it is unreachable by users. You can imagine this as similar to
  // a soft delete. The main use case of work items being not applicable is so
  // that their applicability can be scheduled for some future date.
  bool is_applicable = 40;
  //
  // True if the length of block_reasons is non-empty.
  bool is_blocked = 41;
  //
  // True the length of warnings is non-empty.
  bool has_warnings = 42;
  //
  // Various status tags. Possibilities are defined in
  // work_items/src/main/scala/com/flexport/workitems/helpers/WorkItemsUpdater.scala
  repeated string status_tags = 43;
  //
  // The state for the work item. Possibilities are defined in
  // work_items/src/main/scala/com/flexport/workitems/persistence/models/WorkItemsRow.scala
  google.protobuf.StringValue state = 44;
  //
  // The automation type for the work item. Defaults to MANUAL
  string automation_type = 45;
  //
  // The automation availability
  google.protobuf.BoolValue automation_availability = 46;
  //
  // The automation result
  google.protobuf.BoolValue automation_result = 47;
  //
  // The automation failed reason
  google.protobuf.StringValue automation_failed_reason = 48;
  //
  // The automation updated time stamp
  google.protobuf.Timestamp automation_updated_at = 49;
  //
  // Section: Timestamps
  //
  google.protobuf.Timestamp completed_at_time = 50;
  google.protobuf.Timestamp created_at_time = 51;
  google.protobuf.Timestamp due_at_time = 52;
  //
  // TODO: store snoozed_at when a work item is snoozed (currently we only store
  // snoozed_until)
  google.protobuf.Timestamp snoozed_at_time = 53;
  google.protobuf.Timestamp snoozed_until_time = 54;
  google.protobuf.Timestamp updated_at_time = 55;
  //
  // The snoozed reason is a json object that currently has reasonCode and reasonText keys.
  // Do not change this number 56. Even though it is not a Timestamp, if we change the number,
  // we have to make sure we never reuse 56 because reusing tag numbers can cause issues:
  // https://protobuf.dev/programming-guides/dos-donts/
  google.protobuf.Struct snoozed_reason = 56;
  google.protobuf.Timestamp applicable_at_time = 57;
  //
  // For metrics purpose, this is the actual time when a work item truly became applicable.
  google.protobuf.Timestamp last_applicable_at_time = 58;
  //
  // Section: Misc.
  //
  // User-facing strings about why a work item is blocked.
  repeated string block_reasons = 60;
  //
  // User-facing strings indicating warnings for a work item.
  repeated string warnings = 61;
  //
  // The Metadata (stored as jsonb).
  google.protobuf.Struct metadata = 62;
  //
  repeated string view_permissions = 63;
  //
  string details = 64;

  google.protobuf.Struct work_context = 65;

  // Revision number
  uint64 revision = 66;
  // Section: Timestamps 2
  // firstCompletedAt
  google.protobuf.Timestamp first_completed_at_time = 70;
  // firstCompletedBy
  google.protobuf.StringValue first_completed_by = 71;
  // firstDueAt
  google.protobuf.Timestamp first_due_at_time = 72;
  // automationDueAt
  google.protobuf.Timestamp automation_due_at_time = 73;
}
