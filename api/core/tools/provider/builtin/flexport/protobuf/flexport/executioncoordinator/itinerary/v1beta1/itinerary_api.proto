// TEAM: forwarding_platform

syntax = "proto3";

package flexport.executioncoordinator.itinerary.v1beta1;

import "flexport/executioncoordinator/itinerary/v1beta1/itinerary.proto";
import "flexport/executioncoordinator/types/enums/v1/execution_task_params_case.proto";
import "flexport/executioncoordinator/types/enums/v1/node_tag.proto";
import "flexport/executioncoordinator/types/enums/v1/transport_mode.proto";
import "google/protobuf/field_mask.proto";
import "google/protobuf/wrappers.proto";

option java_multiple_files = true;
option java_outer_classname = "ItineraryApiProto";
option java_package = "com.flexport.executioncoordinator.itinerary.v1beta1";
option ruby_package = "Flexport::ExecutionCoordinator::Itinerary::V1Beta1";

// An API for interacting with Itinerary entities.
service ItineraryAPI {
  // Retrieves an Itinerary.
  rpc GetItinerary(GetItineraryRequest) returns (GetItineraryResponse);

  // Retrieves all revisions of an Itinerary.
  rpc ListItineraryRevisions(ListItineraryRevisionsRequest) returns (ListItineraryRevisionsResponse);

  // Creates or updates an Itinerary. Idempotent.
  rpc UpsertItinerary(UpsertItineraryRequest) returns (UpsertItineraryResponse);

  // Batch edits to the itinerary.
  rpc BatchItineraryOperation(BatchItineraryOperationRequest) returns (BatchItineraryOperationResponse);

  rpc GetItineraries(GetItinerariesRequest) returns (GetItinerariesResponse);
}

service ItineraryUpdateAPI {
  // Update a part of the full route with schedule. This API keeps the other part of the route unchanged and
  // cascade the schedule accordingly.
  rpc UpdatePartialRoute(UpdatePartialRouteRequest) returns (UpdatePartialRouteResponse);
  // Update full route. This API can be used for use cases like requote acceptance route change(will override
  // existing route, but keep schedule if any leg has actual dates)
  rpc UpdateFullRoute(UpdateFullRouteRequest) returns (UpdateFullRouteResponse);
  // Update multiple nodes in a route. This API keeps legs and other nodes unchanged and only update the associated
  // node information for multiple existing nodes. Node id is unchanged.
  rpc BatchUpdateNode(BatchUpdateNodeRequest) returns (BatchUpdateNodeResponse);
  // Update only the schedule for a given order. This API updates the legs in the request and replace the schedule
  // with the one in the request. Its request contains only the legs that need updates, not all legs in itinerary.
  rpc UpdateSchedule(UpdateScheduleRequest) returns (UpdateScheduleResponse);
}

message UpdatePartialRouteRequest {
  // Legs can be placed in any order.
  repeated Leg unordered_legs = 1;
  // Nodes are expected to be ordered.
  // It means all origin nodes come before the origin port and
  // all destination nodes come after the destination port.
  // Transfer port should be ordered between origin and destination port.
  // First and last node should exist in the existing itinerary. Predecessor route
  // of the first node will be kept unchanged in the existing itinerary.
  // Successor route of the last node will be kept unchanged
  // in the existing itinerary. Schedule will be cascaded accordingly.
  repeated Node ordered_nodes = 2;

  string execution_order_fid = 3;

  // global unique idempotent key to make the API idempotent
  string idempotent_key = 4;
  // Human user that triggers the schedule update, if there is
  string user_fid = 5;
}

message UpdatePartialRouteResponse {
  repeated EntityActivity activity = 1;
}

message UpdateFullRouteRequest {
  // should contain all legs for the shipment
  repeated Leg unordered_legs = 1;
  // should contain all ordered nodes for the shipment
  repeated Node ordered_nodes = 2;
  string execution_order_fid = 3;
  // global unique idempotent key to make the API idempotent
  string idempotent_key = 4;
  // Human user that triggers the schedule update, if there is
  string user_fid = 5;
}

message UpdateFullRouteResponse {
  repeated EntityActivity activity = 1;
}

message BatchUpdateNodeRequest {
  repeated Node nodes = 1;

  string execution_order_fid = 2;
  // idempotent key to make the API idempotent
  string idempotent_key = 3;
  // Human user that triggers the schedule update, if there is
  string user_fid = 4;
}

message BatchUpdateNodeResponse {
  repeated EntityActivity activity = 1;
}

message UpdateScheduleRequest {
  repeated LegSchedule leg_schedule = 1;

  string execution_order_fid = 2;
  // idempotent key to make the API idempotent
  string idempotent_key = 3;
  // Human user that triggers the schedule update, if there is
  string user_fid = 4;
}

message UpdateScheduleResponse {
  repeated EntityActivity activity = 1;
}

message LegSchedule {
  string leg_id = 1;

  Timetable estimated_timetable = 2;
  Timetable actual_timetable = 3;
  Timetable scheduled_timetable = 4;

  // Indicate if each part of a LegSchedule is updated. This is to support partial update.
  // Its path value could be estimated_timetable.departure_date, estimated_timetable.arrival_date,
  // actual_timetable.departure_date, actual_timetable.arrival_date,
  // scheduled_timetable.departure_date, scheduled_timetable.arrival_date,
  google.protobuf.FieldMask update_mask = 5;
}

// The request for GetItinerary.
message GetItineraryRequest {
  string shipment_fid = 1;
  //
  // Specific revision to get, if any. The default value (0) returns the current revision.
  uint32 revision = 2;
}

// The response for GetItinerary.
message GetItineraryResponse {
  Itinerary itinerary = 1;
}

// The request message for ListItineraryRevisions.
message ListItineraryRevisionsRequest {
  string shipment_fid = 1;
}

// The response message for ListItineraryRevisions.
// If the request identifier was a shipment_fid and the shipment_fid has no
// corresponding ExecutionOrder entity (yet), then an empty list is returned.
message ListItineraryRevisionsResponse {
  repeated Itinerary revisions = 1;
}

// A request message containing an Itinerary to upsert.
message UpsertItineraryRequest {
  //
  // The new Itinerary
  Itinerary itinerary = 1;
  //
  // Source of the request to change the Itinerary. This field is required.
  ItineraryRevisionSource revision_source = 2;
}

// The response for UpsertItinerary.
message UpsertItineraryResponse {
  Itinerary itinerary = 1;
}

message ExecutionTaskMetadata {
  flexport.executioncoordinator.types.enums.v1.ExecutionTaskParamsCase execution_task_params_case = 1;
  bool keep_task = 2;
  bool labeled_as_cartage = 3;
}

// Add's a new itinerary leg by prepending it the the supplied
// prepend_leg_ids
//   Prepending an existing leg (adding to the start)
//      before:  a -> b
//      after:   c -*-> a -> b
message PrependLegOperation {
  string prepend_leg_id = 1;
  string place_fid = 2;
  string terminal_or_cfs_fid = 3;
  flexport.executioncoordinator.types.enums.v1.TransportMode transport_mode = 4;
  ExecutionTaskMetadata execution_task_metadata = 5;

  // If present, this will only assign the cargo_fids defined in this
  // array to the leg. If not present, the new leg will clone the execution_cargos
  // from the prepend_leg_id (with new cargo_fids)
  repeated string cargo_fids = 6;
  google.protobuf.StringValue voyage_tracking_number = 7;
}

// Add's a new itinerary leg by extending it to the supplied
// extending_leg_ids
//   Extending an existing leg (adding to the end)
//      before:  a -> b
//      after:   a -> b -*-> c
message ExtendLegOperation {
  string extend_leg_id = 1;

  string place_fid = 2;
  string terminal_or_cfs_fid = 3;
  google.protobuf.StringValue voyage_tracking_number = 7;
  google.protobuf.StringValue carrier_fid = 8;
  google.protobuf.StringValue partner_fid = 9;
  Timetable estimated_timetable = 10;
  Timetable actual_timetable = 11;

  flexport.executioncoordinator.types.enums.v1.TransportMode transport_mode = 4;
  ExecutionTaskMetadata execution_task_metadata = 5;

  // If present, this will only assign the cargo_fids defined in this
  // array to the leg. If not present, the new leg will clone the execution_cargos
  // from the extended_leg_id (with new cargo_fids)
  repeated string cargo_fids = 6;
}

// Add a leg with a new execution task. If the origin or destination referred by the legs is a new
// node, also need to specify new_origin_node or new_destination_node.
message AddLegOperation {
  Leg leg = 1;
  Node new_origin_node = 2;
  Node new_destination_node = 3;
  ExecutionTaskMetadata execution_task_metadata = 4;
}

// Add's a new itinerary leg by splitting it the the supplied
// split_leg_ids
//   Splitting an existing leg (introduce a new leg between the origin/dest)
//      before:  a -> b
//      after:   a -> c -*-> b
message SplitLegOperation {
  string split_leg_id = 1;

  string place_fid = 2;
  string terminal_or_cfs_fid = 3;
  flexport.executioncoordinator.types.enums.v1.TransportMode transport_mode = 4;
  ExecutionTaskMetadata execution_task_metadata = 5 [deprecated = true];
  ExecutionTaskMetadata task_metadata_for_left_leg = 6;
  ExecutionTaskMetadata task_metadata_for_right_leg = 7;
}

message LegCargo {
  string container_fid = 1;
  uint32 number_of_pieces = 2;
}

// Add's a new itinerary parallel leg
//   Parallel an existing leg (add another leg from the same origin/dest node)
//      before:  a -> b
//      after:   a -> b
//               a -*-> b
message AddParallelLegOperation {
  string origin_node_id = 1;
  string destination_node_id = 2;
  string execution_task_fid = 3;

  flexport.executioncoordinator.types.enums.v1.TransportMode transport_mode = 4;
  string voyage_tracking_number = 5;
  repeated LegCargo cargo = 6 [deprecated = true];
}

// Deletes an itinerary leg
message DeleteLegOperation {
  string leg_id = 1;
}

// Deletes an itinerary node
message DeleteNodeOperation {
  string node_id = 1;
  bool preserve_following_leg = 2;
}

// Updates an existing itinerary leg
message UpdateLegOperation {
  // Required. The leg to update
  string leg_id = 1;

  // If present, operation will only update the fields defined in the mask.
  // If not present, operation will update all fields if values are not default.
  // Nested fields require a full path to the field.
  //
  // For example, to update the carrier_fid and estimated_timetable.arrival fields,
  // FieldMaskUtil.fromStringList(Leg.class, List.of("carrier_fid", "estimated_timetable.arrival_date"));
  google.protobuf.FieldMask update_mask = 13;

  string carrier_fid = 2;
  string partner_fid = 12;
  flexport.executioncoordinator.types.enums.v1.TransportMode transport_mode = 3;
  string vessel_fid = 4;
  string voyage_tracking_number = 5;

  repeated string cargo_fids = 9;

  Timetable estimated_timetable = 7;
  Timetable scheduled_timetable = 18;
  Timetable actual_timetable = 8;

  repeated ItineraryDateRange target_discharge_date_ranges = 16;
  repeated ItineraryDateRange target_delivery_date_ranges = 17;

  repeated LegCargo cargo = 6 [deprecated = true];
  ExecutionTaskMetadata execution_task_metadata = 19;
  FreightType freight_type = 20;
}

// Updates an existing itinerary node
message UpdateNodeOperation {
  string node_id = 1;
  string place_fid = 2;
  string terminal_or_cfs_fid = 3;
  repeated flexport.executioncoordinator.types.enums.v1.NodeTag tags = 6;

  // When updating a destination/origin of a leg, if the node has other incoming legs
  // or outgoing legs, we want to create a new node and point the leg so we don't
  // update other legs accidentally.
  // Example:
  // Before: n1 --leg1--> n2 n1 --leg2--> n2
  // After: n1 --leg1--> n2 n1 --leg2--> n3
  google.protobuf.StringValue incoming_leg_id = 4;
  google.protobuf.StringValue outgoing_leg_id = 5;
}

message MergeLegsOperation {
  repeated string leg_ids = 1;
  Leg shape_of_merged_leg = 2;
}

message BatchItineraryOperation {
  oneof operation {
    PrependLegOperation prepend_leg_operation = 1;
    ExtendLegOperation extend_leg_operation = 2;
    SplitLegOperation split_leg_operation = 3;
    AddParallelLegOperation parallel_leg_operation = 4;

    DeleteLegOperation delete_leg_operation = 5;
    DeleteNodeOperation delete_node_operation = 6;

    UpdateLegOperation update_leg_operation = 7;
    UpdateNodeOperation update_node_operation = 8;

    MergeLegsOperation merge_legs_operation = 9;
    SubgraphReplacementOperation subgraph_replacement_operation = 10;
    AddLegOperation add_leg_operation = 11;
    AutoTagOperation auto_tag_operation = 12;
  }
}

/**
  Subgraph between origin and destination in the existing itinerary will be substituted by added new legs and nodes.
 */
message SubgraphReplacementOperation {
  string substituted_subgraph_origin_node_fid = 1;
  string substituted_subgraph_destination_node_fid = 2;

  repeated Leg replacement_legs = 3;
  repeated Node replacement_nodes = 4;
}

message AutoTagOperation {
  repeated flexport.executioncoordinator.types.enums.v1.NodeTag target_tags = 1;
}

message BatchItineraryOperationRequest {
  string shipment_fid = 1;
  repeated BatchItineraryOperation operations = 2;
  //
  // Source of the request to change the Itinerary. This field is required.
  ItineraryRevisionSource revision_source = 3;
}

message BatchItineraryOperationResponse {
  Itinerary itinerary = 1;
}

message GetItinerariesRequest {
  repeated string shipment_fids = 1;
}

message GetItinerariesResponse {
  repeated GetItineraryResponse itineraries = 1;
}
