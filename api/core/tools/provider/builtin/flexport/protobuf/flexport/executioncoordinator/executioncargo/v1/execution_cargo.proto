// TEAM: forwarding_platform

syntax = "proto3";

package flexport.executioncoordinator.executioncargo.v1;

import "flexport/executioncoordinator/executioncargo/v1/cargo_process.proto";
import "flexport/executioncoordinator/executioncargo/v1/cargo_upserter.proto";
import "flexport/executioncoordinator/types/cargo/v1/active_iso_6346_container.proto";
import "flexport/executioncoordinator/types/cargo/v1/air_cargo.proto";
import "flexport/executioncoordinator/types/cargo/v1/transiting_customer_consignment.proto";
import "flexport/os/v1/types/cargo/v1/base_cargo.proto";
import "google/protobuf/timestamp.proto";

option java_multiple_files = true;
option java_outer_classname = "ExecutionCargoProto";
option java_package = "com.flexport.executioncoordinator.executioncargo.v1";
option ruby_package = "Flexport::ExecutionCoordinator::ExecutionCargo::V1";

// A mutable ExecutionCargo entity, used to maintain a reference to a set of cargo during execution.
//
// Think of the ExecutionCargo API as "S3 for cargo data". It is a simple key/value store with
// revision history. The keys are ExecutionCargo fids. The values are ExecutionCargo proto messages.
//
// NOTE: execution_cargo_fids are not like container_fids. Multiple execution_cargo_fid may point to
// data about the same container_fid. execution_cargo_fids are cheap to produce and have meaning
// only within the context of an ExecutionTask. See http://go/ec-cargo for details.
//
// Example use cases:
//
// 1. Multiple sets of cargo planned within a single ExecutionTask.
//    - Consider destination trucking for an ocean FCL shipment with multiple containers, each to
//      be delivered from the same Port of Unloading to the same client destination warehouse.
//    - Per the conventions of the drayage industry, a single Delivery Order is generated by
//      Flexport Ops and sent to the trucking carrier for _all_ the containers. Similarly, the
//      Delivery Order is represented with a single ExecutionTask for all the containers.
//    - But each container will have its lifecycle and own set of events like "picked up from port
//      at time X" or "scheduled to be delivered within time range Y".
//    - When the trucking ExecutionProvider emits events, how can the consumers know which container
//      the event is about? Each event includes a cargo_fid that refers to a specific container.
//      These ExecutionCargo fids were created by the ExecutionPlanner when the ExecutionTask was
//      created.
//
// 2. Cargo split by a carrier.
//    - Air carriers sometimes cannot fit all the ULDs for a single Master Airway Bill on the same
//      flight. The implication for Flexport is that the cargo for one shipment / one ExecutionOrder
//      / one air ExecutionTask may get put onto separate flights, even though internally we planned
//      a single ExecutionTask with all cargo moving on the same flights.
//    - Similar to use case (1), when this happens different units of cargo within the same
//      ExecutionTask will have separate lifecycles and events. The solution is the same: events
//      include cargo_fids to disambiguate which cargo is referred to.
//    - Unlike use case (1), the ExecutionCargo entities are created by the air ExecutionProvider
//      rather than the ExecutionPlanner. The cargo split occurred during the execution of the
//      ExecutionTask rather than during planning.
//
// A few other notes:
//
// - Any system can create an ExecutionCargo entity at any time. Any system can revise an entity
//   at any time. However, multiple systems should not mutate the same ExecutionCargo entity.
//   We may introduce the notion of a private key to disallow multiple-system editing if this
//   becomes a problem.
// - ExecutionCargo entities should be treated as mostly immutable, except in cases where the
//   system that created the entity needs to update some aspect of the cargo based on new data.
// - There are no internal associations within the ExecutionCoordinator between ExecutionCargo and
//   other domain concepts like ExecutionTask and ExecutionOrder. ExecutionCargo is its own island
//   and could be deployed as a separate service.
//
message ExecutionCargo {
  //
  // Unique identifier for the entity.
  string fid = 1;
  //
  // Time the entity was created.
  google.protobuf.Timestamp created_time = 3;
  //
  // Revision number of the entity. Increments by one each time the entity is mutated, starting
  // at 1. Included in events and reads from the ExecutionCoordinator; ignored during writes.
  int32 revision = 2;
  //
  // Time the current entity revision was created.
  google.protobuf.Timestamp revision_created_time = 4;

  ExecutionCargoRevisionSource revision_source = 12;

  //
  // Value of the entity.
  oneof value {
    flexport.os.v1.types.cargo.v1.BaseCargo base_cargo = 5;
    flexport.executioncoordinator.types.cargo.v1.ActiveIso6346Container iso_6346_container = 7;
    //
    // Use iso_6346_container instead.
    flexport.executioncoordinator.types.cargo.v1.ActiveIso6346Container drayage_container = 6 [deprecated = true];
    flexport.executioncoordinator.types.cargo.v1.AirCargoUld uld = 8;
    flexport.executioncoordinator.types.cargo.v1.AirCargoCartons loose_cartons = 9;
    flexport.executioncoordinator.types.cargo.v1.TransitingCustomerConsignment transiting_customer_consignment = 11;
  }

  // Allow for customer defined natural identifier of this cargo.
  // Example use case is Apple Delivery Number (DN)
  string customer_reference_id = 10;
}

// A source of an ExecutionOrder revision.
message ExecutionCargoRevisionSource {
  //
  // The user that created the revision. Might be a bot.
  string user_fid = 1;
  //
  // The "service or group" (a la http://go/fid) that upserted the ExecutionCargo revision.
  CargoUpserter cargo_upserter = 2;
  //
  // The process that created the revision.
  CargoProcess cargo_process = 3;
  //
  // Free text note about the revision.
  string note = 4;
}
