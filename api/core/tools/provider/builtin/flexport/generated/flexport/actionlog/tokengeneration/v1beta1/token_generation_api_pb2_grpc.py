# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from flexport.actionlog.tokengeneration.v1beta1 import token_generation_api_pb2 as flexport_dot_actionlog_dot_tokengeneration_dot_v1beta1_dot_token__generation__api__pb2


class TokenGenerationAPIStub(object):
    """
    * Service Boundary Documentation:
    * -------------------------------
    * The Token generation API for the Action Log Network isolated service.
    * The purpose of this GRPC service is for the Action Log NIS to provide scoped ActionLog tokens
    * that power the <ActionLog...> react component (The component for rendering Action Logs on the frontend).
    * The generic <ActionLog...> react component passes this token to the graphql endpoints living in the ActionLog NIS.
    * The NIS uses this token to:
    * - Figure out what actions types to return to this component
    * - What actors should the action be scoped to
    * - What targets should the actions be scoped to
    * - Return actions with a particular set of properties
    * - What filters are to be rendered on the <ActionLog...> react component
    * - (Note examples below don't use proto instantiations for explanation and use pseudocode instead)
    * Each action log token request has five arguments:
    *  - Actions: List of "registered" (see how to register your action in go/actionlog) actions
    ex: ["ExampleAction", "ShipmentChallengedAccessAction", ]
    This argument scopes the token to return any (A reader may note this is implemented as an OR clause) of the actions present in that list

    *  - Actors: List of targets. An Actor is an entity that is opaque to action. An Entity is an opaque piece of data
    that contains a "type" and "id". This argument scopes the action to return all actions that have been performed by any of these actors (A reader may note this is an OR clause)
    ex: pseudocode: actors =  [Entity(entity_id: '123', type: 'User')]. If this argument is nil, no scope is placed.
    If this argument is an empty array, it returns actions that have no actor which is no actions (Aka 0 actions returned)

    *  - Targets: List of actors. An Actor is an entity that is opaque to action. An Entity is an opaque piece of data
    that contains a "type" and "id".  This argument scopes the action to return all actions that have been performed on any of these targets (A reader may note this is an OR clause))
    ex: pseudocode: actors =  [Entity(entity_id: '123', type: 'User')]. If this argument is nil, no scope is placed.
    If this argument is an empty array, this argument scopes the action to return all actions that have been performed on any of these targets, which is no target
    (Aka 0 actions returned)

    Note: [] value for actors or targets return no actions while nil value returns all. This is for completeness sake.
    The behavior when actors/targets is an empty array is based on the supposition in our code that every "action" logged to actionLog
    has an "Actor" and has a "Target". Thus there are no actions in the data storage that don't have an actor/target associated with them.
    *
    *  - Properties: List of property scopes. Every action logged to actionLog has a properties field which is either nil or a json object/ruby hash.
    This list is to scope actions to only actions having a certain property. If this field is nil, we place no scoping on the actions returned to the frontend by property.
    If this list is empty, the token is scoped to return actions with no properties (Return actions with nil properties).
    If the list is non-empty, it returns

    What is a property scope?
    ans: A property scope is one-level dictionary like
    {"property1" => 10, "property2" => true, "property3.property4" => "foo"}. It means we should
    return all actions that contain a property hash having a field property 1 with integer value 10,
    field property2 with boolean value true, and a nested field property4 within field property3 having
    string value "foo".

    *  - Filters. List of filters. This encodes the list of UI user filters the <ActionLog..> component will render on the frontend.
    *    Currently we support filtering by action type, actor, target and occurred_at (date range filter)
    *
    *
    *  To learn more about what ActionLog is go to go/actionlog and reach out to the #app-framework


    Set of GRPC APIS to generate action log tokens to power the <ActionLog..> react component.
    Generate a scoped Action Log token. Ultimately, this token is passed to the frontend
    to power the generic <ActionLog...> react component (which makes graphql queries to the ActionLog NIS with token as an argument containing
    authorizations and scopes and clamps)
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.GenerateActionLogToken = channel.unary_unary(
                '/flexport.actionlog.tokengeneration.v1beta1.TokenGenerationAPI/GenerateActionLogToken',
                request_serializer=flexport_dot_actionlog_dot_tokengeneration_dot_v1beta1_dot_token__generation__api__pb2.GenerateActionLogTokenRequest.SerializeToString,
                response_deserializer=flexport_dot_actionlog_dot_tokengeneration_dot_v1beta1_dot_token__generation__api__pb2.GenerateActionLogTokenResponse.FromString,
                )


class TokenGenerationAPIServicer(object):
    """
    * Service Boundary Documentation:
    * -------------------------------
    * The Token generation API for the Action Log Network isolated service.
    * The purpose of this GRPC service is for the Action Log NIS to provide scoped ActionLog tokens
    * that power the <ActionLog...> react component (The component for rendering Action Logs on the frontend).
    * The generic <ActionLog...> react component passes this token to the graphql endpoints living in the ActionLog NIS.
    * The NIS uses this token to:
    * - Figure out what actions types to return to this component
    * - What actors should the action be scoped to
    * - What targets should the actions be scoped to
    * - Return actions with a particular set of properties
    * - What filters are to be rendered on the <ActionLog...> react component
    * - (Note examples below don't use proto instantiations for explanation and use pseudocode instead)
    * Each action log token request has five arguments:
    *  - Actions: List of "registered" (see how to register your action in go/actionlog) actions
    ex: ["ExampleAction", "ShipmentChallengedAccessAction", ]
    This argument scopes the token to return any (A reader may note this is implemented as an OR clause) of the actions present in that list

    *  - Actors: List of targets. An Actor is an entity that is opaque to action. An Entity is an opaque piece of data
    that contains a "type" and "id". This argument scopes the action to return all actions that have been performed by any of these actors (A reader may note this is an OR clause)
    ex: pseudocode: actors =  [Entity(entity_id: '123', type: 'User')]. If this argument is nil, no scope is placed.
    If this argument is an empty array, it returns actions that have no actor which is no actions (Aka 0 actions returned)

    *  - Targets: List of actors. An Actor is an entity that is opaque to action. An Entity is an opaque piece of data
    that contains a "type" and "id".  This argument scopes the action to return all actions that have been performed on any of these targets (A reader may note this is an OR clause))
    ex: pseudocode: actors =  [Entity(entity_id: '123', type: 'User')]. If this argument is nil, no scope is placed.
    If this argument is an empty array, this argument scopes the action to return all actions that have been performed on any of these targets, which is no target
    (Aka 0 actions returned)

    Note: [] value for actors or targets return no actions while nil value returns all. This is for completeness sake.
    The behavior when actors/targets is an empty array is based on the supposition in our code that every "action" logged to actionLog
    has an "Actor" and has a "Target". Thus there are no actions in the data storage that don't have an actor/target associated with them.
    *
    *  - Properties: List of property scopes. Every action logged to actionLog has a properties field which is either nil or a json object/ruby hash.
    This list is to scope actions to only actions having a certain property. If this field is nil, we place no scoping on the actions returned to the frontend by property.
    If this list is empty, the token is scoped to return actions with no properties (Return actions with nil properties).
    If the list is non-empty, it returns

    What is a property scope?
    ans: A property scope is one-level dictionary like
    {"property1" => 10, "property2" => true, "property3.property4" => "foo"}. It means we should
    return all actions that contain a property hash having a field property 1 with integer value 10,
    field property2 with boolean value true, and a nested field property4 within field property3 having
    string value "foo".

    *  - Filters. List of filters. This encodes the list of UI user filters the <ActionLog..> component will render on the frontend.
    *    Currently we support filtering by action type, actor, target and occurred_at (date range filter)
    *
    *
    *  To learn more about what ActionLog is go to go/actionlog and reach out to the #app-framework


    Set of GRPC APIS to generate action log tokens to power the <ActionLog..> react component.
    Generate a scoped Action Log token. Ultimately, this token is passed to the frontend
    to power the generic <ActionLog...> react component (which makes graphql queries to the ActionLog NIS with token as an argument containing
    authorizations and scopes and clamps)
    """

    def GenerateActionLogToken(self, request, context):
        """
        * Scenarios for known failed responses:
        *   - Pass in an ActionType that is not registered in the ActionLog service in the action types array.
        *   - Pass in an unknown filter type. ActionLog has a set of filter types (Ex: OccuredAt filter, action type filter, actor filter, target filter)
        that you can enable on the component on the token. If you specify,
        a type that isn't in this set, you will get a failure
        *   - Pass in a nil in the actors or targets array ex: [actor1, nil, actor2]
        *   - Pass in a nil in the filters array ex: [filter1, nil, filter2]
        *   - Pass in a nil in the property scopes array [{<property scope >}, nil, {<property scope 2>}]
        *   - Pass in a property value of an unrecognized type aka not :STRING_VALUE, :INTEGER_VALUE or :BOOLEAN_VALUE

        The GRPC API to generate an action log token.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_TokenGenerationAPIServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'GenerateActionLogToken': grpc.unary_unary_rpc_method_handler(
                    servicer.GenerateActionLogToken,
                    request_deserializer=flexport_dot_actionlog_dot_tokengeneration_dot_v1beta1_dot_token__generation__api__pb2.GenerateActionLogTokenRequest.FromString,
                    response_serializer=flexport_dot_actionlog_dot_tokengeneration_dot_v1beta1_dot_token__generation__api__pb2.GenerateActionLogTokenResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'flexport.actionlog.tokengeneration.v1beta1.TokenGenerationAPI', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class TokenGenerationAPI(object):
    """
    * Service Boundary Documentation:
    * -------------------------------
    * The Token generation API for the Action Log Network isolated service.
    * The purpose of this GRPC service is for the Action Log NIS to provide scoped ActionLog tokens
    * that power the <ActionLog...> react component (The component for rendering Action Logs on the frontend).
    * The generic <ActionLog...> react component passes this token to the graphql endpoints living in the ActionLog NIS.
    * The NIS uses this token to:
    * - Figure out what actions types to return to this component
    * - What actors should the action be scoped to
    * - What targets should the actions be scoped to
    * - Return actions with a particular set of properties
    * - What filters are to be rendered on the <ActionLog...> react component
    * - (Note examples below don't use proto instantiations for explanation and use pseudocode instead)
    * Each action log token request has five arguments:
    *  - Actions: List of "registered" (see how to register your action in go/actionlog) actions
    ex: ["ExampleAction", "ShipmentChallengedAccessAction", ]
    This argument scopes the token to return any (A reader may note this is implemented as an OR clause) of the actions present in that list

    *  - Actors: List of targets. An Actor is an entity that is opaque to action. An Entity is an opaque piece of data
    that contains a "type" and "id". This argument scopes the action to return all actions that have been performed by any of these actors (A reader may note this is an OR clause)
    ex: pseudocode: actors =  [Entity(entity_id: '123', type: 'User')]. If this argument is nil, no scope is placed.
    If this argument is an empty array, it returns actions that have no actor which is no actions (Aka 0 actions returned)

    *  - Targets: List of actors. An Actor is an entity that is opaque to action. An Entity is an opaque piece of data
    that contains a "type" and "id".  This argument scopes the action to return all actions that have been performed on any of these targets (A reader may note this is an OR clause))
    ex: pseudocode: actors =  [Entity(entity_id: '123', type: 'User')]. If this argument is nil, no scope is placed.
    If this argument is an empty array, this argument scopes the action to return all actions that have been performed on any of these targets, which is no target
    (Aka 0 actions returned)

    Note: [] value for actors or targets return no actions while nil value returns all. This is for completeness sake.
    The behavior when actors/targets is an empty array is based on the supposition in our code that every "action" logged to actionLog
    has an "Actor" and has a "Target". Thus there are no actions in the data storage that don't have an actor/target associated with them.
    *
    *  - Properties: List of property scopes. Every action logged to actionLog has a properties field which is either nil or a json object/ruby hash.
    This list is to scope actions to only actions having a certain property. If this field is nil, we place no scoping on the actions returned to the frontend by property.
    If this list is empty, the token is scoped to return actions with no properties (Return actions with nil properties).
    If the list is non-empty, it returns

    What is a property scope?
    ans: A property scope is one-level dictionary like
    {"property1" => 10, "property2" => true, "property3.property4" => "foo"}. It means we should
    return all actions that contain a property hash having a field property 1 with integer value 10,
    field property2 with boolean value true, and a nested field property4 within field property3 having
    string value "foo".

    *  - Filters. List of filters. This encodes the list of UI user filters the <ActionLog..> component will render on the frontend.
    *    Currently we support filtering by action type, actor, target and occurred_at (date range filter)
    *
    *
    *  To learn more about what ActionLog is go to go/actionlog and reach out to the #app-framework


    Set of GRPC APIS to generate action log tokens to power the <ActionLog..> react component.
    Generate a scoped Action Log token. Ultimately, this token is passed to the frontend
    to power the generic <ActionLog...> react component (which makes graphql queries to the ActionLog NIS with token as an argument containing
    authorizations and scopes and clamps)
    """

    @staticmethod
    def GenerateActionLogToken(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/flexport.actionlog.tokengeneration.v1beta1.TokenGenerationAPI/GenerateActionLogToken',
            flexport_dot_actionlog_dot_tokengeneration_dot_v1beta1_dot_token__generation__api__pb2.GenerateActionLogTokenRequest.SerializeToString,
            flexport_dot_actionlog_dot_tokengeneration_dot_v1beta1_dot_token__generation__api__pb2.GenerateActionLogTokenResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
